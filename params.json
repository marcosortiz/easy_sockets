{
  "name": "Easy sockets",
  "tagline": "Over and over I see developers struggling to implement basic sockets with features available on ruby socket stdlib.",
  "body": "# Easy Sockets\r\n\r\n[![Gem Version][GV img]][Gem Version]\r\n[![Build Status][BS img]][Build Status]\r\n[![Dependency Status][DS img]][Dependency Status]\r\n[![Code Climate][CC img]][Code Climate]\r\n[![Coverage Status][CS img]][Coverage Status]\r\n\r\n[Gem Version]: https://rubygems.org/gems/easy_sockets\r\n[Build Status]: https://travis-ci.org/marcosortiz/easy_sockets\r\n[Dependency Status]: https://gemnasium.com/marcosortiz/easy_sockets\r\n[Code Climate]: https://codeclimate.com/github/marcosortiz/easy_sockets\r\n[Coverage Status]: https://codeclimate.com/github/marcosortiz/easy_sockets/coverage\r\n\r\n[GV img]: https://badge.fury.io/rb/easy_sockets.svg\r\n[BS img]: https://travis-ci.org/marcosortiz/easy_sockets.svg?branch=master\r\n[DS img]: https://gemnasium.com/marcosortiz/easy_sockets.svg\r\n[CC img]: https://codeclimate.com/github/marcosortiz/easy_sockets/badges/gpa.svg\r\n[CS img]: https://codeclimate.com/github/marcosortiz/easy_sockets/badges/coverage.svg\r\n\r\n## Description\r\n\r\nOver and over I see developers struggling to implement basic sockets with features available on ruby socket stdlib.\r\n\r\neasy_sockets, takes care of basic details that usually are overlooked by developers when implementing TCP/Unix sockets from scratch.\r\n\r\nI also strongly recommend [the following book](http://www.jstorimer.com/products/working-with-tcp-sockets) if you want to learn more about TCP sockets.\r\n\r\n> UDP socket support is comming soon.\r\n\r\n### Dependencies\r\n\r\neasy_sockets only uses the following ruby stdlib gems:\r\n\r\n- sockets\r\n- logger\r\n- timeout (just to raise Timeout::Error)\r\n\r\n### Transparent idempotent connect and disconnect operations\r\n\r\nYou don't needneed to worry about connecting your socket (you can still call it if you want). All you need to do is call `send_msg`. If the socket object is not connected yet, it will automatically try to connect the socket before sending the message. You still need to disconnect your socket after using it.\r\n\r\nThe `connect` and `disconnect` methods are idempotent methods. That means you can call them over and over again and they will only try to do something (connect and disconnect respectively) when the instance of your socket object is disconnected and connected respectively.\r\n\r\nThe code bellow illustrates this:\r\n\r\n```ruby\r\nirb(main):001:0> require 'easy_sockets'\r\n=> true\r\nirb(main):002:0> s = EasySockets::TcpSocket.new\r\n=> #<EasySockets::TcpSocket:0x007fd16bb69308 @logger=nil, @timeout=0.5, @separator=\"\\r\\n\", @connected=false, @port=2000, @host=\"127.0.0.1\">\r\nirb(main):003:0> s.connected\r\n=> false\r\nirb(main):004:0> s.connect\r\n=> true\r\nirb(main):005:0> s.connected\r\n=> true\r\nirb(main):006:0> s.connect\r\n=> nil\r\nirb(main):007:0> s.connect\r\n=> nil\r\nirb(main):008:0> s.connected\r\n=> true\r\nirb(main):009:0> s.disconnect\r\n=> true\r\nirb(main):010:0> s.connected\r\n=> false\r\nirb(main):011:0> s.disconnect\r\n=> nil\r\nirb(main):012:0> s.disconnect\r\n=> nil\r\n```\r\n\r\n### Safe connect, read and write timeout implementation\r\n\r\nThere is a lot of material on the internet saying [why you should not use ruby timeout stdlib](http://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/). However, over and over I see developers using the timeout stdlib for production code!\r\n\r\neasy_sockets implements connect, read and write timeouts using [IO.select](http://ruby-doc.org/core-2.3.1/IO.html#method-c-select).\r\n\r\n### Framing Messages\r\n\r\nUsually, if you don't want to open and close a new connection everytime you need to send something to the server, you need to implement some sort of message framing. Openning (and closing) a new connection for each message, generates unnecessary overhead. While this might be ok for some communications where the messsage exchange rate is low, it might be a show stopper when this rate needs to be bigger.\r\n\r\nMessage framing is an agreement between client and server on the message format. That way clients and server can signal that one message is ending and another on is beginning.\r\n\r\nThere are numerous ways of framing messages. easy_sockets support 2:\r\n\r\n1. **Message separators:** When pass the `:separator` option when creating your socket, easy_sockets will add it to the end of the message. For instance, if you setup `separator: \"\\r\\n\"` and you call `send_msg(\"some_message\")`, the server will receive `\"some_message\\r\\n\"`.\r\n\r\n2. **No separators**: When you pass the option `no_separator: true` when creating your socket, easy_sockets will not add anything to the end of the message. This is useful when both client and server uses a more specific protocol. For instance, both client and server know that the first 4 bytes of the message represent and little ending integer, and depending on the value of that integer, the message will have a specific size and format.\r\n\r\nWhether to use separators or not, is totally up to what both client and server expects.\r\n\r\n> If you decide to use new lines as the message separator, remember that it is `\\n` on Unix systems but `\\r\\n` on Windows. So, be sure that both client and server are using the same separator.\r\n \r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n```ruby\r\ngem 'easy_sockets'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install easy_sockets\r\n\r\n## Usage\r\n\r\nMake sure you have netcat installed on your system. We will use it to emulate our servers.\r\n\r\n### TCP Sockets\r\n\r\nOpen up a terminal window and type the following to start a TCP server:\r\n```bash\r\nnc -ckl 2500\r\n```\r\n\r\nOn another terminal window, run the following [code](https://github.com/marcosortiz/easy_sockets/blob/master/examples/tcp_socket.rb) to start the client:\r\n```ruby\r\nrequire 'easy_sockets'\r\n\r\nhost = ARGV[0] || '127.0.0.1'\r\n\r\nport = ARGV[1].to_i\r\nport = 2500 if port <= 0\r\n\r\nopts = {\r\n    host:      host,\r\n    port:      port,\r\n    timeout:   300,\r\n    separator: \"\\r\\n\",\r\n    logger: Logger.new(STDOUT),\r\n}\r\ns = EasySockets::TcpSocket.new(opts)\r\n[:INT, :QUIT, :TERM].each do |signal|\r\n    Signal.trap(signal) do\r\n        exit\r\n    end\r\nend\r\n\r\nloop do\r\n    puts \"Please write the message you want to send and hit ENTER, or type Ctrl+c to quit:\"\r\n    msg = gets.chomp\r\n    s.send_msg(msg)\r\nend\r\n```\r\n\r\nThen typing `sample_request` in the client terminal, you should see:\r\n```\r\n$ bundle exec ruby examples/tcp_socket.rb \r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\nsample_request\r\nD, [2016-06-30T15:17:39.648945 #90385] DEBUG -- : Successfully connected to tcp://127.0.0.1:2500.\r\nD, [2016-06-30T15:17:39.649044 #90385] DEBUG -- : Sending \"sample_request\\r\\n\"\r\n```\r\n\r\nAnd the server terminal window should display:\r\n```\r\n$ nc -ckl 2500\r\nsample_request\r\n\r\n```\r\n\r\nThen type `sample_response` on the server terminal window, and you should see:\r\n```\r\n$ nc -ckl 2500\r\nsample_request\r\nsample_response\r\n\r\n```\r\n\r\nAnd the client window should show:\r\n```\r\n$ bundle exec ruby examples/tcp_socket.rb \r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\nsample_request\r\nD, [2016-06-30T15:17:39.648945 #90385] DEBUG -- : Successfully connected to tcp://127.0.0.1:2500.\r\nD, [2016-06-30T15:17:39.649044 #90385] DEBUG -- : Sending \"sample_request\\r\\n\"\r\nD, [2016-06-30T15:19:52.494791 #90385] DEBUG -- : Got \"sample_response\\r\\n\"\r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\n\r\n```\r\n\r\nPress `Ctrl+c` on the client and server terminal windows to terminate both.\r\n\r\n### Unix Sockets\r\n\r\nOpen up a terminal window and type the following to start a Unix server:\r\n```bash\r\nnc -Ucl /tmp/test_socket\r\n```\r\n\r\nOn another terminal window, run the following [code](https://github.com/marcosortiz/easy_sockets/blob/master/examples/unix_socket.rb) to start the client:\r\n```ruby\r\nrequire 'easy_sockets'\r\n\r\nhost = ARGV[0] || '127.0.0.1'\r\n\r\nsocket_path = ARGV[1]\r\nsocket_path ||= '/tmp/test_socket'\r\n\r\nopts = {\r\n    host:      host,\r\n    socket_path: socket_path,\r\n    timeout:   300,\r\n    separator: \"\\n\",\r\n    logger: Logger.new(STDOUT),\r\n}\r\ns = EasySockets::UnixSocket.new(opts)\r\n[:INT, :QUIT, :TERM].each do |signal|\r\n    Signal.trap(signal) do\r\n        exit\r\n    end\r\nend\r\n\r\nloop do\r\n    puts \"Please write the message you want to send and hit ENTER, or type Ctrl+c to quit:\"\r\n    msg = gets.chomp\r\n    s.send_msg(msg)\r\nend\r\n```\r\n\r\nThen typing `sample_request` in the client terminal, you should see:\r\n```\r\nmarcosortiz@~/dev/easy_sockets$ bundle exec ruby examples/unix_socket.rb \r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\nsample_request\r\nD, [2016-06-30T15:38:10.303188 #96993] DEBUG -- : Successfully connected to /tmp/test_socket.\r\nD, [2016-06-30T15:38:10.303265 #96993] DEBUG -- : Sending \"sample_request\\n\"\r\n```\r\n\r\nAnd the server terminal window should display:\r\n```\r\n$ nc -Ul /tmp/test_socket\r\nsample_request\r\n\r\n```\r\n\r\nThen type `sample_response` on the server terminal window, and you should see:\r\n```\r\n$ nc -Ul /tmp/test_socket\r\nsample_request\r\nsample_response    \r\n\r\n```\r\n\r\nAnd the client window should show:\r\n```\r\n$ bundle exec ruby examples/unix_socket.rb \r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\nsample_request\r\nD, [2016-06-30T15:38:10.303188 #96993] DEBUG -- : Successfully connected to /tmp/test_socket.\r\nD, [2016-06-30T15:38:10.303265 #96993] DEBUG -- : Sending \"sample_request\\n\"\r\nD, [2016-06-30T15:38:23.503411 #96993] DEBUG -- : \"sample_response\\n\"\r\nD, [2016-06-30T15:38:23.503488 #96993] DEBUG -- : Got \"sample_response\\n\"\r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\n\r\n```\r\n\r\nPress `Ctrl+c` on the client and server terminal windows to terminate both. Also, type `rm -rf /tmp/test_socket` to remove the socket file.\r\n\r\n### UDP Sockets\r\n\r\nOpen up a terminal window and type the following to start a TCP server:\r\n```bash\r\nnc -ukcl 2500\r\n```\r\n\r\nOn another terminal window, run the following [code](https://github.com/marcosortiz/easy_sockets/blob/master/examples/udp_socket.rb) to start the client:\r\n```ruby\r\nrequire 'easy_sockets'\r\n\r\nhost = ARGV[0] || '127.0.0.1'\r\n\r\nport = ARGV[1].to_i\r\nport = 2500 if port <= 0\r\n\r\nopts = {\r\n    host:      host,\r\n    port:      port,\r\n    timeout:   300,\r\n    separator: \"\\r\\n\",\r\n    logger: Logger.new(STDOUT),\r\n}\r\ns = EasySockets::UdpSocket.new(opts)\r\n[:INT, :QUIT, :TERM].each do |signal|\r\n    Signal.trap(signal) do\r\n        exit\r\n    end\r\nend\r\n\r\nloop do\r\n    puts \"Please write the message you want to send and hit ENTER, or type Ctrl+c to quit:\"\r\n    msg = gets.chomp\r\n    s.send_msg(msg)\r\nend\r\n```\r\n\r\nThen typing `sample_request` in the client terminal, you should see:\r\n```\r\n$ bundle exec ruby examples/udp_socket.rb \r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\nsample_request\r\nD, [2016-07-08T10:45:17.935787 #83697] DEBUG -- : Successfully connected to udp://127.0.0.1:2500.\r\nD, [2016-07-08T10:45:17.935893 #83697] DEBUG -- : Sending \"sample_request\\r\\n\"\r\n\r\n```\r\n\r\nAnd the server terminal window should display:\r\n```\r\n$ nc -ukcl 2500\r\nsample_request\r\n\r\n```\r\n\r\nThen type `sample_response` on the server terminal window, and you should see:\r\n```\r\n$ nc -ukcl 2500\r\nsample_request\r\nsample_response\r\n\r\n```\r\n\r\nAnd the client window should show:\r\n```\r\n$ bundle exec ruby examples/udp_socket.rb \r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\nsample_request\r\nD, [2016-07-08T10:45:17.935787 #83697] DEBUG -- : Successfully connected to udp://127.0.0.1:2500.\r\nD, [2016-07-08T10:45:17.935893 #83697] DEBUG -- : Sending \"sample_request\\r\\n\"\r\nD, [2016-07-08T10:45:22.086731 #83697] DEBUG -- : Got \"sample_response\\r\\n\"\r\nPlease write the message you want to send and hit ENTER, or type Ctrl+c to quit:\r\n\r\n```\r\n\r\nPress `Ctrl+c` on the client and server terminal windows to terminate both.\r\n\r\n## Development\r\n\r\nAfter checking out the repo, run `bin/setup` to install dependencies. Then, run `rake spec` to run the tests. You can also run `bin/console` for an interactive prompt that will allow you to experiment.\r\n\r\nTo install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).\r\n\r\n## 5. Contributing\r\n\r\nBug reports and pull requests are welcome on GitHub at https://github.com/marcosortiz/easy_sockets.\r\n\r\n\r\n## 6. License\r\n\r\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}